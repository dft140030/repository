function [combinePropPerTimeInt] = smactinPropPerTimeInt(smPropPerTimeInt, ...
    actinPropPerTimeInt,combineConditions,threshMet,smactinFlag)

%% SMACTINPROPPERTIMEINT
%  In general, compares actin kinetic events with neighboring SM motion.
%  Impose restrictions applying to actin, SM, or both to infer desired
%  results.
%
%  SYNOPSIS: [combinePropPerTimeInt] = smactinPropPerTimeInt(smPropPerTimeInt,...
%                actinPropPerTimeInt,smCond,actinCond,combineCond)
%
%  INPUT: smPropPerTimeInt: vector of structures containing various
%                           properties of single molecules
%
%      actinPropPerTimeInt: vector of structures containing various
%                           properties of actin speckles/events
%
%              smactinFlag: structure of flag with various fields imposing
%                           restrictions on the computation
%
%                       .combFlag: vector of integers from 1 to 9 pertaining to
%                                  the particular combination of properties that
%                                  should be calculated (might want to have a matrix
%                                  of these flags if using multiple
%                                  combinations per movie)
%
%                       .randFlag: = 0: no randomization of neighbors
%                                  = 1: objects are assigned nearest neighbor(s) at
%                                       random
%                                  = 2: take subset of nearest neighbors or
%                                       matched neighbors to objects and assign 
%                                       members of the subset to objects at random
%
%                          .match: = 1: properties of objects and nearest neighbors for speckles, 
%                                       kinetic scores, and single molecule properties. Below is
%                                       a list of combinations of properties.
%                                  = 2: properties of neighbors about a match radius of the object.                      
%                                       Nearest neighbors will not necessarily be included in this class.
%                                       There will be multiple neighbors per an object. Averaged properties
%                                       of these neighbors about a match radius of the object will also be
%                                       calculated
%
%                      .synthData: = 0: single-molecule is synthetically generated by speckle property data
%                                  = 1: single-molecule is not synthetically generated by speckle property data
%
%
%        combineConditions: vector of structures with various fields imposing
%                           restrictions pertaining to both actin and SM.
%
%                  .matchRadius: vector of radius' for matching a SM to a kinetic event
%                                or speckle
%
%                  .fsmInterval: number of SM frames normally existing per
%                                FSM frame
%
%                .firstFsmFrame: the first frame of speckles that should be
%                                considered for matching
%
%                threshMet: vector of cell vectors containing sm indices
%                           that survive a minimum lifetime (observations)
%                           and exist within a mask obtained from qFSM
%
%  OUTPUT: combinePropPerTimeInt: (numMovs x 9) matrix of (3 x 1) cells. Columns
%              of the matrix denote properties of a particular interaction
%
%               cells: = 1: properties of objects and nearest neighbors for speckles, 
%                           kinetic scores, and single molecule properties. Below is
%                           a list of combinations of properties. 
%                      = 2: properties of neighbors about a match radius of the object.                      
%                           Nearest neighbors will not necessarily be included in this class.
%                           There will be multiple neighbors per an object
%                      = 3: averaged properties of neighbors about a match radius of the object;
%                           i.e. the average of properties in cell 2.                      
%
%              column:           (OBJECT        VS.       NEAREST NEIGHBOR)
%                      = c1: speckle properties vs. (n)n speckle properties             (BUGGY)                 
%                      = c2: speckle properties vs. (n)n kinetic score properties       (BUGGY) 
%                      = c3: speckle properties vs. (n)n sm properties                  (BUGGY)
%                      = c4: kinetic score properties vs. (n)n speckle properties       (BUGGY)
%                      = c5: kinetic score properties vs. (n)n kinetic score properties (BUGGY)
%                      = c6: kinetic score properties vs. (n)n sm properties            (BUGGY)
%                      = c7: sm properties vs. (n)n speckle properties
%                      = c8: sm properties vs. (n)n kinetic score properties            (BUGGY)
%                      = c9: sm properties vs. (n)n sm properties                       (BUGGY)
%
% NOTE: The following fields belong to structures contained within mentioned column
%       of cells; i.e. at end of each field description. four categories of fields
%
% 1. Single-Molecules
%               smList: List of particles that exist in the window of time
%                       for time-averaging                          (c3,c6,c7,c8,c9)
%           .smMeanPos: Mean position (x/y-coordinates) per particle in
%                       the window for time-averaging               (c3,c6,c7,c8,c9)
%          .smMeanDisp: mean frame-to-frame displacement for all SM
%                       thresholding survivors in the window of
%                       time-averaging (units: pixels)              (c3,c6,c7,c8,c9)
%         .smNetVelocity: SM velocity vector  per frame averaged
%                       across a particular interval                (c3,c6,c7,c8,c9)
%          .smNetSpeed: net speed for all SM thresholding survivors
%                       within a particular interval.
%                       (units: pixels/SMframe)                     (c3,c6,c7,c8,c9)
%           .smMeanAmp: mean intensity of a SM track during a particular
%                       window of time                              (c3,c6,c7,c8,c9)
%          .trackClass: classification of all tracks based on moment scaling
%                       spectrum analysis                           
%                       = 0 : immobile
%                       = 1 : confined brownian
%                       = 2 : pure brownian (free diffusion)
%                       = 3 : directed motion                       (c3,c6,c7,c8,c9)
%            .diffCoef: diffusion coefficient with row number corresponding
%                       to particle index                           (c3,c6,c7,c8,c9)
%             .confRad: confinement radius of immobile, confined particle with row 
%                       number corresponding to particle index      (c3,c6,c7,c8,c9)
%   .smComovementAngle: angle of comovement between the receptor and it nn
%                       speckle or sm                               (c3,c7,c8,c9)
%
% 2. Speckles
%         .speckleList: List of speckles that exist in the frame
%                                                                   (c1,c2,c3,c4,c7)
%          .specklePos: The speckle position for a particular FSM 
%                       frame (units: pixels)                       (c1,c2,c3,c4,c7)
%     .speckleVelocity: The speckle velocity from a frame to the
%                       following frame (units: pixels / frame)     (c1,c2,c3,c4,c7)
%        .speckleSpeed: speckle speed from a particular FSM frame to the
%                       following frame (units: pixels / frame)     (c1,c2,c3,c4,c7)
%
% 3. Kinetic Scores
%         .kinScorePos: The positions at which we have kinetic scores
%                       (units: pixels)                             (c2,c4,c5,c6,c8)
%            .kinScore: The kinetic score from the qFSM package     (c2,c4,c5,c6,c8)
%
% 4. Miscellaneous
%         .maskDensity: The number of speckles within a mask divided
%                       by the number of pixels comprising the mask    (all columns)
%          .dist_match: Distance of a particular nn or collection of nns
%                       depending on which structure                   (all columns)
%                 .num: Number of neighbors contained within a specified
%                       disc                                           (all columns)
%           .rad_match: Matching radius to form disc and obtain neighbors
%                       for each speckle, kinetic score, or sm         (all columns)
%
% Deryl Tschoerner, February 2018

numMovs = length(actinPropPerTimeInt);
fsmFrames = nan(numMovs,1);
smIntervals = nan(numMovs,1);
if size(smactinFlag.combFlag,2) == 1
    combinePropPerTimeInt = cell(numMovs,1);
else
    error('error:: matrix formatted combFlag is currently unavailable')
end

for i = 1 : numMovs
    
    %no analysis if no speckles or single-molecules. this row will instead
    %be empty
    if isempty(actinPropPerTimeInt{i,1}) || isempty(smPropPerTimeInt{i,1})
        continue
    end
    
    %intervals of frames per movie
    fsmFrames(i) = length(actinPropPerTimeInt{i});
    smIntervals(i) = length(smPropPerTimeInt{i});
    
    %different fields names to make the program more automative. this is
    %because a 'nn' string is concatenated to fields in some structures in
    %which nns are being found among the same set as the object considered
    fld{1} = {'speckleList','speckleDensity','speckleVelocity','specklePos', ...
        'speckleSpeed','speckleMvmtCohere'};
    fld{2} = {'kinScoreList','kinScoreDensity','kinScore','kinScorePos'};
    fld{3} = {'smList','smDensity','smNetVelocity','smMeanPos','smNetSpeed','smMeanDisp', ...
        'smMeanAmp','diffCoef','confRad','smComvmtAngle','trackClass'};
    
    %looping over all combinations of speckles, ks, and sms for object
    %property assignment
    for iComb = 1 : length(smactinFlag.combFlag(i))        
        
        if smactinFlag.match == 1,iTypeFinal = 1; elseif smactinFlag.match == 2, iTypeFinal = 2;
        
        else
            error(['error:: matchings must be done by nearest neighbor analysis ' ...
                'or by nearest neighbors analysis']);
        end
        
        %assignment of fields native to all combinations
        for iMatch = 1 : iTypeFinal
            
            combinePropPerTimeInt{i,iComb}{iMatch} = repmat(struct('maskDensity',[],'rad_match', ...
                combineConditions.matchRadius(i),'num_match',[],'dist_match',[]),fsmFrames(i) - 1, 1);
        end
        
        %looping over time windows to be considered. reminder: first one is skipped since we pad the
        %first interval just to obtain rate information for speckles
        for k = combineConditions.firstFsmFrame(i) : smIntervals(i)
            
            %looping over all strategies to acquire combined properties.
            %nn, match neighbors, or averaged neighbor properties
            for iMatch = 1 : iTypeFinal
                
                %assignment of nearest neighbor field properties
                for lv = 1 : length(fld{mod(iComb - 1,3) + 1})
                    
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).(fld{mod(iComb - 1,3) + 1}{lv}) = [];
                end
                
                %assignment of object field properties
                for lv = 1 : length(fld{ceil(iComb/3)})
                    
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).(fld{ceil(iComb/3)}{lv}) = [];
                end
                
                %density of speckles within refined mask. apply to all
                %structures
                combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleMaskDensity = ...
                    actinPropPerTimeInt{i}(k).speckleMaskDensity;
                %assign object properties to structures
                switch smactinFlag.combFlag(i)
                    
                    %speckle object properties
                    case {1,2,3}
                        
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleInitPos = [];
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleList = ...
                        actinPropPerTimeInt{i}(k).speckleList;
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).specklePos = ...
                        actinPropPerTimeInt{i}(k).speckleInitPos;                    
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleMvmtCohere = ...
                        actinPropPerTimeInt{i}(k).speckleMvmtCohere;  
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleSpeed = ...
                        actinPropPerTimeInt{i}(k).speckleSpeed / ...
                        combineConditions.fsmInterval(i);
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleVelocity = ...
                        actinPropPerTimeInt{i}(k).speckleVelocity / ...
                        combineConditions.fsmInterval(i);
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).speckleDensity = ...
                        actinPropPerTimeInt{i}(k).speckleDensity;                                                

                    %kinetic score object properties
                    case {4,5,6}
                        
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).kinScorePos = ...
                        actinPropPerTimeInt{i}(k).kinScorePos;
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).kinScore = ...
                        actinPropPerTimeInt{i}(k).kinScore;                    
                    combinePropPerTimeInt{i,iComb}{iNN}(k).kinScoreDensity = ...
                        actinPropPerTimeInt{i}(k).kinScoreDensity;
                    %combinePropPerTimeInt{i,iComb}{iNN}(k).kinScoreList = ...
                        %actinPropPerTimeInt{i}(k).kinScoreList;

                    %single-molecule object properties
                    case {7,8,9}
                        
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).smList = ...
                        threshMet{i}{k};
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).smMeanPos = ...
                        smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:);                    
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).smNetSpeed = ...
                        smPropPerTimeInt{i}(k).netSpeed(threshMet{i}{k},:);
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).smMeanAmp = ...
                        smPropPerTimeInt{i}(k).meanAmp(threshMet{i}{k});
                    combinePropPerTimeInt{i,iComb}{iMatch}(k).diffCoef = ...
                        smPropPerTimeInt{i}(k).diffCoef(threshMet{i}{k});
                    %combinePropPerTimeInt{i,iComb}(k).smDensity = ...
                       %smPropPerTimeInt{i}(k).smDensity(threshMet{i}{k});    
                    if smactinFlag.synthData(i) == 0

                        combinePropPerTimeInt{i,iComb}{iMatch}(k).smMeanDisp = ...
                            smPropPerTimeInt{i}(k).meanDisp(threshMet{i}{k});                    
                        combinePropPerTimeInt{i,iComb}{iMatch}(k).smNetVelocity = ...
                            smPropPerTimeInt{i}(k).netVelocity(threshMet{i}{k},:);
                        combinePropPerTimeInt{i,iComb}{iMatch}(k).confRad = ...
                            smPropPerTimeInt{i}(k).confRad(threshMet{i}{k});
                        combinePropPerTimeInt{i,iComb}{iMatch}(k).trackClass = ...
                            smPropPerTimeInt{i}(k).trackClass(threshMet{i}{k});
                    end               
                end                
            end
        end
    end

    %looping over combinations of speckles, ks, and sms for nn property
    %assignment
    for iComb = 1 : length(smactinFlag.combFlag(i))
        
        %looping over time windows 
        for k = 2 : smIntervals(i)
            %{
            %nn(s) distance between all possible combinations of single molecules,
            %actin, and kinetic score positions per time averaged interval
            posFields = fieldnames(combinePropPerTimeInt{i,iComb}{iMatch}(k));
            posFieldIndx = find(contains(posFields,{'Pos','pos','position','Position'}));
            objPos = posFields(posFieldIndx(2));
            nnPos = posFields(posFieldIndx(1));
            
            distMat = createDistanceMatrix(combinePropPerTimeInt{i,iComb}{iMatch}(k).(nnPos), ...
                combinePropPerTimeInt{i,iComb}{iMatch}(k).(objPos));
            %}
            switch smactinFlag.combFlag(i)
                
                case 1
                distMat = createDistanceMatrix(actinPropPerTimeInt{i}(k).speckleInitPos, ...
                    actinPropPerTimeInt{i}(k).speckleInitPos);
                case 2
                distMat = createDistanceMatrix(actinPropPerTimeInt{i}(k).kinScorePos, ...
                    actinPropPerTimeInt{i}(k).speckleInitPos);
                case 3
                distMat = createDistanceMatrix(smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:), ...
                    actinPropPerTimeInt{i}(k).speckleInitPos);
                case 4
                distMat =  createDistanceMatrix(actinPropPerTimeInt{i}(k).speckleInitPos, ...
                    actinPropPerTimeInt{i}(k).kinScorePos);
                case 5
                distMat = createDistanceMatrix(actinPropPerTimeInt{i}(k).kinScorePos, ...
                    actinPropPerTimeInt{i}(k).kinScorePos);
                case 6
                distMat = createDistanceMatrix(smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:), ...
                    actinPropPerTimeInt{i}(k).kinScorePos);
                case 7
                distMat = createDistanceMatrix(actinPropPerTimeInt{i}(k).speckleInitPos, ...
                    smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:));
                case 8
                distMat = createDistanceMatrix(actinPropPerTimeInt{i}(k).kinScorePos, ...
                    smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:));
                case 9 
                distMat = createDistanceMatrix(smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:), ...
                    smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k},:));
            end

            
            %don't proceed if empty distance matrices
            if isempty(distMat)
                continue
            end
            
            %looping over all strategies to acquire combined properties.
            %nn, match neighbors, or averaged neighbor properties
            NUMMATCH = 1;
            
            %finding nn and nns given objects
            for iCol = 1 : size(distMat,2)

                %nn analysis and if no speckle,ks, or speckle positions then no nn calc
                if smactinFlag.match(i) == 1

                    %if so, then we proceed by assigning nns to objects at random
                    if smactinFlag.randFlag(i) == 1

                        %if so, then we proceed by assuring that a nn
                        %cannot also be its object
                        if iComb == 1 || iComb == 5 || iComb == 9

                            try
                                %specificity since, otherwise, there
                                %would be copies of fields 
                                nn = 'NN';

                                %repeat process until a correct nn is
                                %assigned to an object that is also not itself
                                dummy = true;
                                while dummy

                                    [dist,nnindx] = min(randsample(distMat(:,iCol),size(distMat,1)));
                                    compare = randsample(size(distMat,1),1);

                                    if compare ~= nnindx
                                        dummy = false;
                                    end
                                end
                                
                            catch
                                
                            end
                            
                        %if so, then we proceed by assigning nns to
                        %objects. just take first nn index and distance
                        else

                            dist = randsample(distMat(:,iCol),size(distMat,1));
                            dist = dist(1);
                            nnindx = 1;
                        end

                    %if so, proceed to assign true nearest neighbors to
                    %objects. Later we will randomize these nearest
                    %neighbors if randFlag == 2
                    elseif smactinFlag.randFlag(i) == 0 || smactinFlag.randFlag(i) == 2

                        %if so, proceed to take index of true nearest
                        %neighbor. Use mink to take the
                        %second index and distance since the first is
                        %itself
                        switch smactinFlag.combFlag(i)
                            case {1,5,9}
                                
                            [dist,nnindx] = mink(distMat(:,iCol),2);
                            nnindx = nnindx(end); dist = dist(end);
                            nn = 'NN';
                            
                            case {2,3,4,6,7,8}
                            %if so, proceed to take index of true nearest
                            %neighbor
                            [dist,nnindx] = min(distMat(:,iCol));
                            nn = [];
                            
                            otherwise
                            error('Invalid combination selected')
                        end
                    end

                    %assign nearest neighbor distances
                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).dist_match(iCol,1) = dist;

                    %assign nn properties to structures
                    switch iComb

                        %assigning sm nn properties 
                        case {3,6,9}
                            
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).(fld{mod(iComb - 1,3) + 1}{1})(iCol,1) = ...
                            smPropPerTimeInt{i}(k).smList(threshMet{i}{k}(nnindx));
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smMeanDisp = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smMeanDisp, ...
                            smPropPerTimeInt{i}(k).smMeanDisp(threshMet{i}{k}(nnindx)));                            
                        %combinePropPerTimeInt{i,j}{iMatch}(k).smDensity = ...
                            %vertcat(combinePropPerTimeInt{i,j}{iMatch}(k).smDensity, ...
                            %smPropPerTimeInt{i}(k).smDensity;                                
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smNetSpeed = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smNetSpeed, ...
                            smPropPerTimeInt{i}(k).smNetSpeed(threshMet{i}{k}(nnindx)));
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).diffCoef = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).diffCoef, ...
                            smPropPerTimeInt{i}(k).diffCoef(threshMet{i}{k}(nnindx)));                            
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).confRad = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).confRad, ...
                            smPropPerTimeInt{i}(k).confRad(threshMet{i}{k}(nnindx)));                            
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).trackClass = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).trackClass, ...
                            smPropPerTimeInt{i}(k).trackClass(threshMet{i}{k}(nnindx)));

                        %assigning ks nn properties
                        case {2,5,8}
                            
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).kinScore = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).kinScore, ...
                            actinPropPerTimeInt{i}(k).kinScore(nnindx));                 
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).kinScoreDensity = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{iNN}(k).kinScoreDensity, ...
                            actinPropPerTimeInt{i}(k).kinScoreDensity(nnindx));                        

                        case {1,4,7}
                            
                        %assigning nn speckle indices
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).(fld{mod(iComb - 1,3) + 1}{1})(iCol,1) = ...
                            actinPropPerTimeInt{i}(k).speckleList(nnindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleSpeed = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleSpeed, ...
                            actinPropPerTimeInt{i}(k).speckleSpeed(nnindx));
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleDensity = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleDensity, ...
                            actinPropPerTimeInt{i}(k).speckleDensity(nnindx));
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleMvmtCohere = ...
                            vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleMvmtCohere, ...
                            actinPropPerTimeInt{i}(k).speckleMvmtCohere(nnindx));

                        %net velocity angle between speckle nn and sm
                        %object and assignment of the speckle velocity
                        %for this case. this will be a sm property
                        %NOTE: eventually get to work for j = 1,3,9 if necessary
                        if smactinFlag.combFlag(i) == 7 && smactinFlag.synthData(i) == 0

                            %selecting speckles from the speckle list
                            %which meet nn criteria and extracting
                            %their velocity for storage
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleVelocity = ...
                                vertcat(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleVelocity, ...
                                actinPropPerTimeInt{i}(k).speckleVelocity(nnindx,:));

                            %taking most recent speckle added above and
                            %computing comovement angle with its sm
                            %object. will call this a sm property later
                            vel{1} = combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleVelocity(iCol,:);
                            vel{2} = combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smNetVelocity(iCol,:);                                
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smComvmtAngle(iCol,1) = ...
                                acos(dot(vel{1},vel{2}) / (norm(vel{1}) * norm(vel{2})));
                        end

                        %if so, then since assignment of properties for
                        %the time-window is complete, then randomize
                        %the nn properties to objects. purpose is to
                        %test for similarity of properties for
                        %arbitrary object and true object
                        if iCol == size(distMat,2) && smactinFlag.randFlag(i) == 2 && iComb == 7

                            randindx = randsample(size(distMat,2),size(distMat,2));
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).(fld{mod(iComb - 1,3) + 1}{1}) = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).(fld{mod(iComb - 1,3) + 1}{1})(randindx);
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleSpeed = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleSpeed(randindx);
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleDensity = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleDensity(randindx);
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).dist_match = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).dist_match(randindx);
                        end
                    end

                %code architecture can be similar to if iNN == 1 
                elseif smactinFlag.match(i) == 2

                    %take indices of true neighbors about an object                                              
                    if smactinFlag.randFlag(i) == 0 || smactinFlag.randFlag(i) == 2

                        %if so, proceed to take index of true nearest
                        %neighbor. Use mink to take the
                        %second index and distance since the first is
                        %itself
                        switch smactinFlag.combFlag(i)
                            case {1,5,9}

                            nn = 'NN';
                            mtchindx = find(distMat(:,iCol) <= combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).rad_match);
                            mtchindx = mtchindx(mtchindx ~= iCol);
                            
                            case {2,3,4,6,7,8}

                            nn = [];
                            mtchindx = find(distMat(:,iCol) <= combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).rad_match);
                        end

                    %complete this with random matching from the
                    %superset of speckles   
                    else
                        
                        error(['error:: there is not a feature to randomly select nearest neighbors' ...
                            'from the total population'])                            
                    end

                    %retrieve indices for those neighboring speckles or sms (ks
                    %indices would need to be found)                    
                    switch smactinFlag.combFlag(i)

                        case {1,4,7}
                        %assigning nn speckle indices
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleList']){iCol,1} = ...
                            actinPropPerTimeInt{i}(k).speckleList(mtchindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleList']){iCol,1} = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleList']){iCol,1};
                                                
                        case {3,6,9}
                        %assigning nn sm indices
                        combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smList']){iCol,1} = ...
                            smPropPerTimeInt{i}(k).smList(threshMet{i}{k}(mtchindx));
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smList']){iCol,1} = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smList']){iCol,1};
                    end
                    
                    %store distances of neighbors
                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).dist_match{iCol,1} = distMat(mtchindx,iCol);

                    %store number of neighbors that the object has
                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).num_match(iCol,1) = ...
                        length(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).dist_match{iCol,1});

                    %assignment of neighboring properties to the object
                    switch smactinFlag.combFlag(i)

                    %assignment of neighboring speckle properties given
                    %the object
                    case {1,4,7}                                                        

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'specklePos']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).speckleInitPos(mtchindx,:);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'specklePos'])(iCol,:) = ...
                        [mean(actinPropPerTimeInt{i}(k).speckleInitPos(mtchindx,1)), ...
                        mean(actinPropPerTimeInt{i}(k).speckleInitPos(mtchindx,2))];

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleVelocity']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).speckleVelocity(mtchindx,:);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleVelocity'])(iCol,:) = ...
                        [nanmean(actinPropPerTimeInt{i}(k).speckleVelocity(mtchindx,1)), ...
                        nanmean(actinPropPerTimeInt{i}(k).speckleVelocity(mtchindx,2))];

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleSpeed']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).speckleSpeed(mtchindx) / combineConditions.fsmInterval(i);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleSpeed'])(iCol,1) = ...
                        sqrt(sum(combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).speckleVelocity(iCol,:) .^ 2));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleDensity']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).speckleDensity(mtchindx);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleDensity'])(iCol,1) = ...
                        nanmean(actinPropPerTimeInt{i}(k).speckleDensity(mtchindx));                    
                    
                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleMvmtCohere']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).speckleMvmtCohere(mtchindx);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleMvmtCohere'])(iCol,1) = ...
                        nanmean(actinPropPerTimeInt{i}(k).speckleMvmtCohere(mtchindx));                    

                    %after calculating the net velocity of the
                    %speckles in the neighborhood of the sm, take
                    %the net velocity angle.
                    %
                    %WARNING: This code contains a bug that does not allow
                    %smactinMat.m to concatenate properties with the
                    %others; i.e. the number of rows are sometimes off
                    if smactinFlag.combFlag(i) == 7 %eventually get to work for j = 1,3,7,9

                        if ~isempty(mtchindx)

                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){iCol,1} = [];
                            %continue
                        else
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){iCol,1} = NaN;
                        end

                        for iAng = 1 : length(mtchindx)

                            vel{1} = combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).speckleVelocity{iCol,1}(iAng,:);
                            vel{2} = combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).smNetVelocity(iCol,:);
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){iCol,1}(iAng,1) = ...
                                acos(dot(vel{1},vel{2}) / (norm(vel{1}) * norm(vel{2})));
                        end

                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smComvmtAngle'])(iCol,1) = ...
                            nanmean(real(combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){iCol,1}));
                    end

                    %if so, then since assignment of properties for
                    %the time-window is complete, then randomize
                    %the nn properties to objects. purpose is to
                    %test for similarity of properties for
                    %arbitrary object and true object
                    if iCol == size(distMat,2) && smactinFlag.randFlag(i) == 2 && smactinFlag.combFlag(i) == 7 

                        randindx = randsample(size(distMat,2),size(distMat,2));                            
                        for randlv = 1 : length(randindx)

                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleList']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleList']){randindx(randlv)};
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'specklePos']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'specklePos']){randindx(randlv)};
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleVelocity']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleVelocity']){randindx(randlv)};
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleSpeed']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleSpeed']){randindx(randlv)};                                
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleDensity']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'speckleDensity']){randindx(randlv)};
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smComvmtAngle']){randindx(randlv)};
                            combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'dist_match']){randlv} = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'dist_match']){randindx(randlv)};
                            
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'dist_match']) = ...
                                combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'dist_match']);
                        end

                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleList']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleList'])(randindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'specklePos']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'specklePos'])(randindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleVelocity']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleVelocity'])(randindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleSpeed']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleSpeed'])(randindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleDensity']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'speckleDensity'])(randindx);
                        combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smComvmtAngle']) = ...
                            combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smComvmtAngle'])(randindx);
                    end
                        
                    case {2,5,8}
                        
                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'kinScorePos']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).kinScorePos(mtchindx,:);                            
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'kinScorePos'])(iCol,:) = ...
                        [mean(actinPropPerTimeInt{i}(k).kinScorePos(mtchindx,1)), ...
                        mean(actinPropPerTimeInt{i}(k).kinScorePos(mtchindx,2))];

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'kinScore']){iCol,1} = ...
                        actinPropPerTimeInt{i}(k).kinScore(mtchindx);  
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'kinScore'])(iCol,1) = ...
                        mean(actinPropPerTimeInt{i}(k).kinScore(mtchindx));

                    case {3,6,9}

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smMeanPos']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).meanPos(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smMeanPos'])(iCol,:) = ...
                        [mean(smPropPerTimeInt{i}(k).meanPos((threshMet{i}{k}(mtchindx)),1))
                        mean(smPropPerTimeInt{i}(k).meanPos((threshMet{i}{k}(mtchindx)),2))];

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smNetVelocity']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).netVelocity(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smNetVelocity'])(iCol,:) = ...
                        [nanmean(smPropPerTimeInt{i}(k).netVelocity((threshMet{i}{k}(mtchindx)),1))
                        nanmean(smPropPerTimeInt{i}(k).netVelocity((threshMet{i}{k}(mtchindx)),2))];

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smNetSpeed']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).netSpeed(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smNetSpeed'])(iCol,1) = ...
                        nanmean(smPropPerTimeInt{i}(k).netSpeed((threshMet{i}{k}(mtchindx))));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smMeanDisp']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).meanDisp(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smMeanDisp'])(iCol,1) = ...
                        mean(smPropPerTimeInt{i}(k).meanDisp((threshMet{i}{k}(mtchindx))));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'smMeanAmp']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).meanAmp(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'smMeanAmp'])(iCol,1) = ...
                        mean(smPropPerTimeInt{i}(k).meanAmp((threshMet{i}{k}(mtchindx))));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'diffCoef']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).diffCoef(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'diffCoef'])(iCol,1) = ...
                        nanmean(smPropPerTimeInt{i}(k).diffCoef((threshMet{i}{k}(mtchindx))));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'confRad']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).confRad(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'confRad'])(iCol,1) = ...
                        nanmean(smPropPerTimeInt{i}(k).confRad((threshMet{i}{k}(mtchindx))));

                    combinePropPerTimeInt{i,iComb}{NUMMATCH}(k).([nn 'trackClass']){iCol,1} = ...
                        smPropPerTimeInt{i}(k).trackClass(threshMet{i}{k}(mtchindx),1);
                    combinePropPerTimeInt{i,iComb}{NUMMATCH + 1}(k).([nn 'trackClass'])(iCol,1) = ...
                        nanmean(smPropPerTimeInt{i}(k).trackClass((threshMet{i}{k}(mtchindx))));
                    end
                end
            end                             
        end        
    end 
end   

end